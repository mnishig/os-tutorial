*予め google するべき知識: アセンブラの制御構造、ファンクションコール、文字列*

**ゴール: アセンブラの基本的にはコードの書き方を学ぶ**

私たちは、オリジナルのブートセクターを作るという目的にだいぶ近づいてきました。

この先の レッスン7 では、カーネルロードの最後のステップとしてディスク読み込みを実装します。
が、その前にアセンブラでの制御構造やファンクションコール、文字列の扱いを習得する必要があります。
これは、本当にカーネルやディスクロードのプログラムを書く前にマスターする必要があります。

文字列
-----

バイトデータのように文字列を定義することができます。ただし、文字列の末尾に null バイト(C言語と同じですね、)
が必要です。末尾に null (0) があることで文字列が終わったことを示します。

```nasm
mystring:
    db 'Hello, World', 0
```

注意しなければいけないのは、' (クォート) で囲まれた文字列はアセンブラによりアスキー文字列に変換されますが、
最後に 0x00 (nullバイト) が出てくるまでその変換を行います。


制御構造
-------

私たちは、すでに以下のようなjmp命令で無限ループを実装しました。:

`jmp $` 

アセンブラのジャンプは直前の命令の結果により動作が変わります。

```nasm
cmp ax, 4      ; if ax = 4
je ax_is_four  ; ax = 4 の時、ラベルに飛んで何か処理します。
jmp else       ; そうでない場合、他の何かを行います。
jmp endif      ; 最後に、正常系のフローを継続します。

ax_is_four:
    .....
    jmp endif

else:
    .....
    jmp endif  ; この例では、本当は必要ありません。が理解のために入れています。(なくても結局、endifのアドレスに進む)

endif:
```

ちょっと考えてみると、ジャンプ命令にはたくさんのパターンがあることに気づきます。
例えば、条件式が = の場合や < の場合などたくさんあると思います。
必要に応じて Google で検索して、その時々に即したジャンプ命令の詳細を調べてみてください。


関数コール
--------

もしかしたらすでに、関数コールは単にラベルにジャンプすることだと気づいているかもしれません。

ただ、引数の取り扱いは少しトリッキーです。
関数にパラメータを渡すには、2つのステップが必要になります:

1. プログラマーは、関数と共有するレジスタを把握する必要があります。共有するメモリアドレスも同様です。
2. 関数コールの前後に副作用を避けるためのコードを追加する必要があります。

ステップ 1
これは簡単です。この例では `al` レジスタ (`ax` も同じ) を使用することにします。

```nasm
mov al, 'X'
jmp print
endprint:

...

print:
    mov ah, 0x0e  ; tty code
    int 0x10      ; 私は、'al' に文字が格納されていることを保証します。
    jmp endprint  ; 終了時の戻り先も予め決めておきます。
```

この例のアプローチだとすぐにコードが読みづらくなりいわゆる「スパゲッティコード」になってしまうだろう。
`print` 関数は、`endprint` ラベルに戻っているがこのままだと `print` 関数をプログラムの他の場所で
呼び出して再利用しにくい。もし、他の関数やプログラムの場所からこの `print` 関数を呼び出すと何が起こるだろう？
あまり想像したくないことが起こることは確かだ。


The correct solution offers two improvements:

- 戻り先(呼び出し元)のアドレスを記憶して関数を実行する
- 関数を呼び出す前のレジスタ群の状態を保存して関数の内部で変更しても副作用を発生させない

戻り先(呼び出し元)のアドレスを記憶するには、2つのjump 命令の代わりに `call`、`ret` 命令の組を使えばいい。

レジスタの値を保存するには、スタックを使う特別な命令 `pusha`、`popa` を使う。
`pusha` で全レジスタをスタックに退避して、あとで必要になったら`popa` で戻せばいい。


外部ファイルのインクルード(読み込み)
------------------------------


もしあなたがプログラマであると仮定するなら、インクルードを説明するまでもないでしょう。
以下のように書けばいいです。(外部ファイルを読み込みます。)

The syntax is
```nasm
%include "file.asm"
```


16進数を表示する
--------------

次のレッスンからディスク読み込みを学ぶと先ほども言いましたが、その前に正しいデータの入力方法を確かめてみます。
`boot_sect_print.asm` と16進数の表示に拡張した `boot_sect_print_hex.asm` を作ります。




コード! 
------

いよいよコードにジャンプする時です。
`boot_sect_print.asm` ファイルは、メインのファイルからインクルードされるサブルーチンです。
内部ではループ処理を用いて1文字づつを画面に表示します。さらに改行するファンクションも追加しています。`\n` で現される改行は実際には、2バイトのデータで表現されます。
その2バイトとは、`0x0A` が newline 文字(改行) で `0x0D` がキャリッジリターン(カーソルを行の先頭に移動する)　です。
試しに、キャリッジリターンを削除すると何が起きるか確かめてください。

まずは、`boot_sect_print.asm` のみを追加して動作するようにしてその後で
`boot_sect_hex.asm` を追加してください。

メインファイル　`boot_sect_main.asm` では上記の2つのファイルをロードし、
文字列または16進数の表示を行います。
もしあなたがこれまでのセクションを理解していれば何も難しいことはないでしょう。
