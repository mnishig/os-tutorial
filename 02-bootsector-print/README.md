*予め google するべき知識: interrupts(割込み), CPU
registers(レジスタ)*

**ゴール: 私たちのブートセクターに文字列表示を追加する**

私たちのとても小さな無限ループしかできないブートセクターを改良して何か表示してみましょう。そのために割り込みについても学びます。

例として "Hello" という文字列を表示することを考えてみます。
+ `al` レジスタ(`ax` レジスタの下位) に表示したい文字列を入れます。
+ `ah` レジスタ(`ax` レジスタの上位) に `0x0e` を入れます。
+ ビデオ割り込み `0x10` を起動します。

`ah` レジスタに入力する `0x0e` は、`al` をttyモードで画面表示するファンクション(機能)です。

コード例では、 `ah` レジスタを一度しかセットしていませんが、もし cpu 上で他のプロセスが同時に動いていていると`ah` レジスタが予期しない値になっていることがあります。

`ah` レジスタに限らないですが、マルチプロセス動作中は、他のプロセスによってレジスタの値が書き換えられて、私たちのプロセスにとっては破壊され、ゴミデータが入っていることになります。

ただ、今の段階のサンプルでは私たちのプロセスが CPUで動作する唯一のプロセスなのでレジスタやフラグの保護についてケアする必要はありません。

文字表示する新しいブートセクター:
```nasm
mov ah, 0x0e ; tty mode
mov al, 'H'
int 0x10
mov al, 'e'
int 0x10
mov al, 'l'
int 0x10
int 0x10 ; 'l' はまだ al にセットされてる、本当?
mov al, 'o'
int 0x10

jmp $ ; このアドレスに jump = 無限ループ

; 0 で埋めて、最後に magic number
times 510 - ($-$$) db 0
dw 0xaa55 
```

`xxd file.bin` でやることもできますが、

nasm でやるにはこうなります:

`nasm -fbin boot_sect_hello.asm -o boot_sect_hello.bin`

`qemu boot_sect_hello.bin`

ブートセクターは、'Hello' と言って、ハングアップするでしょう。
