*予め google するべき知識: セグメンテーション*

**ゴール: 16-ビット リアルモードでセグメンテーションを用いたアドレッシング方法について学ぶ**

もしセグメンテーションについて十分に理解している場合、このセクションはスキップしてかまいません。

レッスン3ですでに `[org]` 擬似命令を利用したセグメンテーションを使用していますが、
セグメンテーションは、簡単に言うとメモリアクセスの際に、あるアドレスからのオフセット値を
使ってアドレスを決定してアクセスする方法のことを言います。

セグメンテーションを行うためには専用のレジスタを使用します。
`cs`、`ds`、`ss`、`es` レジスタがそれにあたります、それぞれ用途別に
コード、データ、スタックと拡張(ユーザー定義)の用途で使用します。

注意: 上記のセグメンテーション用のレジスタは CPU からも「暗黙のうちに」利用されれます。
これが意味することは例えば、一度 `ds` レジスタをセットするとメモリアクセスは
`ds` からのオフセットでアクセスする必要があると言うことです。

[参照] (http://wiki.osdev.org/Segmentation)

Furthermore, to compute the real address we don't just join the two
addresses, but we *overlap* them: `segment << 4 + address`. For example,
if `ds` is `0x4d`, then `[0x20]` actually refers to `0x4d0 + 0x20 = 0x4f0`

さあ、理論はこれで十分です。コードをみてみましょう。

ヒント: `mov` セグメンテーション用のこれらのレジスタには `mov` 命令は使えません。
そのため、一旦、汎用レジスタに値を設定する必要があります。
