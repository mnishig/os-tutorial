*予め google するべき知識: assembler, BIOS*

**ゴール: BIOS がブートディスクとして認識することができるファイルを作る**

つまり私達のオリジナルのブートセクタを作ります。それはとてもエキサイティングで興味深いと思います！

セオリー
-------

コンピューターが起動する時、BIOS は、OS を読み込む方法を知りません。そのタスクは、BIOS ではなく
ブートセクタに任されています。なので、ブートセクタは BIOS が知っている(規定の)場所に配置する必要があります。
その場所は、ディスクの最初のセクター(具体的には シリンダ 0、ヘッド 0、セクタ 0)になります。
その大きは 512 バイトと決められています。

訳注:
上の説明は前提として、IBM PC 互換機で BIOS で FD から起動することを想定している。最近は、BIOS がなく EFI を実装した 
PC が多く存在し、しかも BIOS 互換モードがない PC もある。qemu の上で OS を動作させる場合には上記の前提で問題ないが、
実機で動かす場合には、EFI 対応を考慮する必要がある。


以下は、最もシンプルなブートセクター:

```
e9 fd ff 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[ 29 行以上の 00 (16進数) が続く                 ]
00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa
```

注目するべきなのは、最後尾の値 `0xAA55` です。intel x86 はりトルエンディアンなので
ブートセクターには 55 aa がひっくり返って記録されています。
最初の 3 バイトは無限ループの jump 命令です。

Simplest boot sector ever
-------------------------

あなたは、上記 512 バイトのファイルをバイナリエディタ(hex エディタ)で書くこともできますが、
アセンブラ言語で書けばすごく簡単になります；

```nasm
; 無限ループ (e9 fd ff)
loop:
    jmp loop 

; 上のコード分を 510 バイトから除いたバイト数を 0  で埋める
times 510-($-$$) db 0
; Magic number
dw 0xaa55 
```

コンパイル(アセンブル):
`nasm -f bin boot_sect_simple.asm -o boot_sect_simple.bin`

> OSX 注意: もしエラーが発生したら、チャプター 00 に戻ってインストールしてください。

ちょっと怖いような気もしますが、動かしてみましょう:

`qemu boot_sect_simple.bin`

するとウィンドウが現れて、以下のようなメッセージが表示するはずです。
"Booting from Hard Disk..."

これでだけで、あとは何も起きません。ちょっと拍子抜けでしたか?

