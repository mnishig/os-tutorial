*予め google するべき知識: ハードディスク、シリンダ、ヘッド、セクタ、キャリービット*

**ゴール: カーネルを起動するためにブートセクターでディスクからデータを読み込みます。**

我々の OS はブートセクタの512 バイトには収まらなくなります。となるとカーネルを実行する時にディスクからデータを読み込む必要があります。

幸い、私たちは、どのプラッターを回転させるかどうかなんてことは気にしなくていい、ただいくつかの BIOS こーるをするだけですみます。
`al` に `0x02` をセットしてさらにシリンダ、やヘッド、セクターを指定し `int 0x13` をコール呼び出すと
ディスクにアクセスできる。
それは、前のセクションで文字を画面表示したのとよく似た方法です。

[参照: int 13h ガイド here](http://stanislavs.org/helppc/int_13-2.html)


このレッスンでは初めて *carry bit* を使用します。
*carry bit* は、命令を実行した結果、使用したレジスタの桁数をオーバーしたかを示すものです。:

```nasm
mov ax, 0xFFFF
add ax, 1 ; ax = 0x0000 and carry = 1
```

キャリービットは、直接アクセスすることはできません。`jc` のような制御命令を使って間接的にアクセスします。`jc` 命令はキャリービットがセットされているとジャンプをする命令です。


コード
-----

`boot_sect_disk.asm` では、ディスクリードを完成させています。

`boot_sect_main.asm` はディスク読込みに必要なパラメータを準備して `disk_load`を呼び出しています。
ブートセクターの外にどういう方法でデータを書き出しているかに注意してください。
Notice how we write some extra data which does not actually belong to the boot
sector, since it is outside the 512 bits mark.

ブートセクターは通常セクター1に配置されます(セクター番号は 1 から始まりますから、最初のセクターということです)。つまり、シリンダー 0、ヘッド 0、セクター 1という HDD0上の場所を示しています。

だから、1セクター目の512バイトより後のデータは、セクター 2 以降に配置することになります。

メインルーティンでは、ブートセクターを読込んだあと？時？サンプルデータをセクター 2 に書込んで
フィルして(埋めて)います。

""注意: 動作させてみてコードが正しいように見えるのにエラーが出る場合、qemu が起動させたドライブ(A: とか C:)を正しく指し示すよう `dl` レジスタの値を変更してください。**

BIOS はブートセクタが読み込まれる前に `dl` レジスタをセットしてしまいます。
私(原作者)が気づいた限りでは、qemu が HDD 起動している場合に発生するようだ。

これは2つの方法で回避できる:

1. `-fda` フラグ。`qemu -fda boot_sect_main.bin` とすると `dl` レジスタには、
`0x00` がセットされ、正常に動作するようだ。
2. `-boot` フラグ。`qemu boot_sect_main.bin -boot c` とすると `dl` レジスタは、
`0x80` がセットされるこれは、HDD0 を意味するで、うまくいくようだ。


